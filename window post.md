
## 抽查常见的问题类别
 1. 从存储加载文件耗时太长、或者挂死
 2. 显卡证明过程中出错、奔溃
 3. 网络问题导致往主网提交证明失败

## 问题原因排查步骤
 1. **检查抽查日志是否有错误**
	`grep -i 'panic\|error\|failed'`，如果有错误，则先耐心读懂错误内容，实在无法理解的错误请咨询程序提供方。

 2. **检查关注的窗口的抽查情况**
	例如，当前关注的是索引为8的窗口，那么，我们 `grep -i '"index":8'`，根据grep到的结果不同，便有不同的结论。

	如果没有看到对应该索引的`running window post`日志，则说明这个窗口还没有开始，没有开始的原因可能是抽查时间没到，又或者miner进程已经卡死导致无法正常开始这个窗口的抽查过程。

	如果看到了`running window post`，说明抽查已经开始了，如果没有看到`computing window post`则说明这个窗口开始了但还没有结束，没有结束的原因可能是存储太慢或者显卡证明太慢。如果看到了`computing window post`说明计算已经结束，此时看看计算时间是否超时（例如，超过了30分钟），如果超时了那么肯定就抽查失败了。

	对于没有看到`computing window post`，肯定的是该窗口的计算还没有结束，那么我们可以看看当前的时间，减去`running window post`日志的时间，就知道这个计算过程已经耗时了多久了。如果超过预期，那么我们应该仔细查看日志，看看卡在了哪一个[阶段](#%E6%8A%BD%E6%9F%A5%E8%BF%87%E7%A8%8B%E9%98%B6%E6%AE%B5)，例如是卡在显卡证明阶段？还是卡在读取存储阶段？

	如果一切看起来都正常，那么此时就要考虑是否网络阻塞了，导致无法提交抽查结果。

## 抽查重合的处理
所谓抽查重合，是指在某个窗口时间内，进行两个窗口抽查。这种情况在抽查超时的情况下，几乎必然发生。例如，当前时间段，应该进行第8个窗口的抽查，但是由于读取存储太慢（或者显卡证明太慢等等）导致第7个窗口还没有计算完毕，此时miner又开始第8个窗口的抽查计算。由于两个抽查同时进行着，那么只会慢上加慢，最后不管是第7，还是第8个，都会失败。甚至，第8个窗口在第9个窗口开始时都还没有结束，这就导致抽查一路重合下去，7，8，9，10……一路失败。

此时我们应该要立即重启miner，由于miner重启后，它比较了当前的时间，发现已经到了第8个抽查窗口，他就会开始第8个窗口抽查，而放弃了第7个窗口，进而就避免了抽查重复。

需要特别注意的是，重启抽查miner后，应该立即tail -f 他的log，确认它的行为是预期的，例如确认它开启的是第8个窗口的抽查，而不是第7个，因为如果重启的时机并不是在第8个窗口时间段内，而是第7个窗口的后期，那么miner会继续第7个窗口的抽查，此时我们唯有再次重启miner或者先停止miner等一小段时间，再启动miner以便彻底错开第7个窗口。

## 抽查过程阶段
一个抽查加载及计算分为5部分，分别为：
 1. 加载所有扇区p_aux文件，通过`grep 'load p_aux files end'`可以看到took时间。每个扇区的p_aux文件大小是64字节。
 2. 加载所有扇区merkle tree root，通过`grep 'load merkle tree root: end'`可以看到took时间，每个扇区tree root大小是32字节。
 3. 加载所有扇区merkle tree branch，通过`grep 'vanilla_proofs:finish windowPOST'`可以看到took时间。对于每个扇区，这个过程是需要反复多次读取sealed文件及每一层tree-r-last-*.dat文件的，每个扇区读取的总量大约是几十KB。
 4. 显卡证明，通过`grep 'snark_proof:finish: windowPOST'`可以看到took时间
 5. 关闭上述加载过程涉及到的文件句柄，通过比较`'generate_window_post:drop tree files'`和`'generate_window_post:finish'`两条日志之间的时间差获得该阶段耗时。有时候如果挂载点卡死，就会出现无法关闭文件（因为关闭文件需要挂载点及其文件系统响应）。

步骤1~3是并行（具体并行数量取决于线程池线程数量配置，默认是CPU核数）读取存储的。窗口抽查除了加载及显卡计算时间，还有一些其他的时间开销，例如新封装的扇区发现等等，总的抽查耗时，以`computing window post`日志中的`elapsed`字段为准。

## 以抽查相关的环境变量
 1. **FIL_PROOFS_WINDOW_POST_GPU**

	该变量设置抽查时使用的显卡UUID，如果想使用多个显卡，那么用逗号分割填写多个显卡的UUID。

 2. **BELLMAN_SYNTHESIZE_BATCH**

	该变量设置进行显卡证明时，并发进行电路综合处理的数量，一般设置为4即可。这个变量影响的是证明过程中使用的CPU核心数量，因为电路综合是通过CPU进行的。

 3. **BELLMAN_CALC_BATCH**

	该变量设置进行显卡证明时，并发进行显卡计算处理的数量，这个值越大计算越快，但是这个值是由显卡的显存决定的，因此如果设置过大就会导致显卡显存不足，计算失败。对于显存小于20GB的卡，设置为2较为合适；对于显存大于20GB的卡，设置为4较为合适。例如，2080TI我们设置为2；3090我们设置为4；有些显卡显存小于8GB，可能需要设置为1，例如3070。

 4. **BELLMAN_CUSTOM_GPU**

	这个变量作用是，在显卡驱动无法获取到显卡的CUDA核心数量时，显式地指定显卡的CUDA数量，这样miner进行显卡证明时就能够合理地设置并发参数。目前根据测试，驱动版本460以及之前的都可以提供显卡CUDA核心数量。但是470以及更新的就不能提供了，需要设置该参数。具体来说，如果日志中，出现`WARN bellperson::gpu::utils > Number of CUDA cores for your device`，就表明需要通过该环境变量来设置CUDA核心数量了。某个显卡的CUDA核心数量，可以通过google得到。

 5. **FIL_PROOFS_LOG_GEN_CACHED_PROOF**

	这个变量的作用是，在加载merkle tree随机分支（这个阶段读取存储最多），把每个扇区的耗时打印出来。以便确定哪一个扇区较慢，通过找到该扇区所在的存储，进而可以到具体存储上排查原因。

 6. **FIL_PROOFS_LOG_GEN_CACHED_PROOF_THRESHOLD**

	这个变量的作用是设置FIL_PROOFS_LOG_GEN_CACHED_PROOF的工作阈值，单位是毫秒。默认是1000毫秒，也就是耗时大于等于1秒时才输出日志。

